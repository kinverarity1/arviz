<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>arviz.stats.stats &#8212; ArviZ 0.4.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html"><span><img src="../../../_static/logo.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.4.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../examples/index.html">Gallery</a></li>
                <li><a href="../../../notebooks/Introduction.html">Quickstart</a></li>
                <li><a href="../../../notebooks/InferenceDataCookbook.html">Cookbook</a></li>
                <li><a href="../../../notebooks/XarrayforArviZ.html">InferenceData</a></li>
                <li><a href="../../../notebooks/Numba.html">Numba</a></li>
                <li><a href="../../../api.html">API</a></li>
                <li><a href="../../../usage.html">Usage</a></li>
                <li><a href="../../../about.html">About</a></li>
            
            
              
              
            
            
            
                <a class="icon" href="https://github.com/arviz-devs/arviz">
                    <img src="../../../_static/GitHub-Mark-32px.png"
                    style="position: absolute; top: 15px; right: 30px; border: 0;"></a>
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for arviz.stats.stats</h1><div class="highlight"><pre>
<span></span><span class="c1"># pylint: disable=too-many-lines</span>
<span class="sd">&quot;&quot;&quot;Statistical functions in ArviZ.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">st</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">minimize</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>

<span class="kn">from</span> <span class="nn">..data</span> <span class="k">import</span> <span class="n">convert_to_inference_data</span><span class="p">,</span> <span class="n">convert_to_dataset</span>
<span class="kn">from</span> <span class="nn">.diagnostics</span> <span class="k">import</span> <span class="n">_multichain_statistics</span><span class="p">,</span> <span class="n">_mc_error</span><span class="p">,</span> <span class="n">ess</span><span class="p">,</span> <span class="n">_circular_standard_deviation</span>
<span class="kn">from</span> <span class="nn">.stats_utils</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">make_ufunc</span> <span class="k">as</span> <span class="n">_make_ufunc</span><span class="p">,</span>
    <span class="n">wrap_xarray_ufunc</span> <span class="k">as</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">,</span>
    <span class="n">logsumexp</span> <span class="k">as</span> <span class="n">_logsumexp</span><span class="p">,</span>
    <span class="n">ELPDData</span><span class="p">,</span>
    <span class="n">stats_variance_2d</span> <span class="k">as</span> <span class="n">svar</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="n">_var_names</span><span class="p">,</span> <span class="n">Numba</span><span class="p">,</span> <span class="n">_numba_var</span>

<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;compare&quot;</span><span class="p">,</span> <span class="s2">&quot;hpd&quot;</span><span class="p">,</span> <span class="s2">&quot;loo&quot;</span><span class="p">,</span> <span class="s2">&quot;psislw&quot;</span><span class="p">,</span> <span class="s2">&quot;r2_score&quot;</span><span class="p">,</span> <span class="s2">&quot;summary&quot;</span><span class="p">,</span> <span class="s2">&quot;waic&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="compare"><a class="viewcode-back" href="../../../generated/arviz.compare.html#arviz.compare">[docs]</a><span class="k">def</span> <span class="nf">compare</span><span class="p">(</span>
    <span class="n">dataset_dict</span><span class="p">,</span>
    <span class="n">ic</span><span class="o">=</span><span class="s2">&quot;waic&quot;</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;BB-pseudo-BMA&quot;</span><span class="p">,</span>
    <span class="n">b_samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="s2">&quot;deviance&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compare models based on WAIC or LOO cross-validation.</span>

<span class="sd">    WAIC is the widely applicable information criterion, and LOO is leave-one-out</span>
<span class="sd">    (LOO) cross-validation. Read more theory here - in a paper by some of the</span>
<span class="sd">    leading authorities on model selection - dx.doi.org/10.1111/1467-9868.00353</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset_dict : dict[str] -&gt; InferenceData</span>
<span class="sd">        A dictionary of model names and InferenceData objects</span>
<span class="sd">    ic : str</span>
<span class="sd">        Information Criterion (WAIC or LOO) used to compare models. Default WAIC.</span>
<span class="sd">    method : str</span>
<span class="sd">        Method used to estimate the weights for each model. Available options are:</span>

<span class="sd">        - &#39;stacking&#39; : stacking of predictive distributions.</span>
<span class="sd">        - &#39;BB-pseudo-BMA&#39; : (default) pseudo-Bayesian Model averaging using Akaike-type</span>
<span class="sd">          weighting. The weights are stabilized using the Bayesian bootstrap.</span>
<span class="sd">        - &#39;pseudo-BMA&#39;: pseudo-Bayesian Model averaging using Akaike-type</span>
<span class="sd">          weighting, without Bootstrap stabilization (not recommended).</span>

<span class="sd">        For more information read https://arxiv.org/abs/1704.02030</span>
<span class="sd">    b_samples: int</span>
<span class="sd">        Number of samples taken by the Bayesian bootstrap estimation.</span>
<span class="sd">        Only useful when method = &#39;BB-pseudo-BMA&#39;.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        The shape parameter in the Dirichlet distribution used for the Bayesian bootstrap. Only</span>
<span class="sd">        useful when method = &#39;BB-pseudo-BMA&#39;. When alpha=1 (default), the distribution is uniform</span>
<span class="sd">        on the simplex. A smaller alpha will keeps the final weights more away from 0 and 1.</span>
<span class="sd">    seed : int or np.random.RandomState instance</span>
<span class="sd">        If int or RandomState, use it for seeding Bayesian bootstrap. Only</span>
<span class="sd">        useful when method = &#39;BB-pseudo-BMA&#39;. Default None the global</span>
<span class="sd">        np.random state is used.</span>
<span class="sd">    scale : str</span>
<span class="sd">        Output scale for IC. Available options are:</span>

<span class="sd">        - `deviance` : (default) -2 * (log-score)</span>
<span class="sd">        - `log` : 1 * log-score (after Vehtari et al. (2017))</span>
<span class="sd">        - `negative_log` : -1 * (log-score)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A DataFrame, ordered from lowest to highest IC. The index reflects the key with which the</span>
<span class="sd">    models are passed to this function. The columns are:</span>
<span class="sd">    IC : Information Criteria (WAIC or LOO).</span>
<span class="sd">        Smaller IC indicates higher out-of-sample predictive fit (&quot;better&quot; model). Default WAIC.</span>
<span class="sd">        If `scale == log` higher IC indicates higher out-of-sample predictive fit (&quot;better&quot; model).</span>
<span class="sd">    pIC : Estimated effective number of parameters.</span>
<span class="sd">    dIC : Relative difference between each IC (WAIC or LOO) and the lowest IC (WAIC or LOO).</span>
<span class="sd">        It&#39;s always 0 for the top-ranked model.</span>
<span class="sd">    weight: Relative weight for each model.</span>
<span class="sd">        This can be loosely interpreted as the probability of each model (among the compared model)</span>
<span class="sd">        given the data. By default the uncertainty in the weights estimation is considered using</span>
<span class="sd">        Bayesian bootstrap.</span>
<span class="sd">    SE : Standard error of the IC estimate.</span>
<span class="sd">        If method = BB-pseudo-BMA these values are estimated using Bayesian bootstrap.</span>
<span class="sd">    dSE : Standard error of the difference in IC between each model and the top-ranked model.</span>
<span class="sd">        It&#39;s always 0 for the top-ranked model.</span>
<span class="sd">    warning : A value of 1 indicates that the computation of the IC may not be reliable.</span>
<span class="sd">        This could be indication of WAIC/LOO starting to fail see</span>
<span class="sd">        http://arxiv.org/abs/1507.04544 for details.</span>
<span class="sd">    scale : Scale used for the IC.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compare the centered and non centered models of the eight school problem:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data1 = az.load_arviz_data(&quot;non_centered_eight&quot;)</span>
<span class="sd">           ...: data2 = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: compare_dict = {&quot;non centered&quot;: data1, &quot;centered&quot;: data2}</span>
<span class="sd">           ...: az.compare(compare_dict)</span>

<span class="sd">    Compare the models using LOO-CV, returning the IC in log scale and calculating the</span>
<span class="sd">    weights using the stacking method.</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: az.compare(compare_dict, ic=&quot;loo&quot;, method=&quot;stacking&quot;, scale=&quot;log&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ascending</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;negative_log&quot;</span><span class="p">:</span>
            <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">ascending</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">ic</span> <span class="o">=</span> <span class="n">ic</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ic</span> <span class="o">==</span> <span class="s2">&quot;waic&quot;</span><span class="p">:</span>
        <span class="n">ic_func</span> <span class="o">=</span> <span class="n">waic</span>
        <span class="n">df_comp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;waic&quot;</span><span class="p">,</span> <span class="s2">&quot;p_waic&quot;</span><span class="p">,</span> <span class="s2">&quot;d_waic&quot;</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="s2">&quot;se&quot;</span><span class="p">,</span> <span class="s2">&quot;dse&quot;</span><span class="p">,</span> <span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="s2">&quot;waic_scale&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">scale_col</span> <span class="o">=</span> <span class="s2">&quot;waic_scale&quot;</span>

    <span class="k">elif</span> <span class="n">ic</span> <span class="o">==</span> <span class="s2">&quot;loo&quot;</span><span class="p">:</span>
        <span class="n">ic_func</span> <span class="o">=</span> <span class="n">loo</span>
        <span class="n">df_comp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;loo&quot;</span><span class="p">,</span> <span class="s2">&quot;p_loo&quot;</span><span class="p">,</span> <span class="s2">&quot;d_loo&quot;</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="s2">&quot;se&quot;</span><span class="p">,</span> <span class="s2">&quot;dse&quot;</span><span class="p">,</span> <span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="s2">&quot;loo_scale&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">scale_col</span> <span class="o">=</span> <span class="s2">&quot;loo_scale&quot;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The information criterion </span><span class="si">{}</span><span class="s2"> is not supported.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ic</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;stacking&quot;</span><span class="p">,</span> <span class="s2">&quot;bb-pseudo-bma&quot;</span><span class="p">,</span> <span class="s2">&quot;pseudo-bma&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The method </span><span class="si">{}</span><span class="s2">, to compute weights, is not supported.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>

    <span class="n">ic_se</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_se&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
    <span class="n">p_ic</span> <span class="o">=</span> <span class="s2">&quot;p_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
    <span class="n">ic_i</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_i&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>

    <span class="n">ics</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">dataset_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">ics</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ic_func</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pointwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)])</span>
    <span class="n">ics</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">names</span>
    <span class="n">ics</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">ic</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;stacking&quot;</span><span class="p">:</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ic_i_val</span> <span class="o">=</span> <span class="n">_ic_matrix</span><span class="p">(</span><span class="n">ics</span><span class="p">,</span> <span class="n">ic_i</span><span class="p">)</span>
        <span class="n">exp_ic_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ic_i_val</span> <span class="o">/</span> <span class="n">scale_value</span><span class="p">)</span>
        <span class="n">last_col</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">def</span> <span class="nf">w_fuller</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">weights</span><span class="p">,</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)]))</span>

        <span class="k">def</span> <span class="nf">log_score</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">w_full</span> <span class="o">=</span> <span class="n">w_fuller</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                <span class="n">score</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exp_ic_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w_full</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">score</span>

        <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">w_full</span> <span class="o">=</span> <span class="n">w_fuller</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">last_col</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">last_col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                    <span class="n">grad</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">exp_ic_i</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">exp_ic_i</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">last_col</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">exp_ic_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w_full</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">grad</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">last_col</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">cols</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">last_col</span><span class="p">)]</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ineq&quot;</span><span class="p">,</span> <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)},</span>
            <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ineq&quot;</span><span class="p">,</span> <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">},</span>
        <span class="p">]</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
            <span class="n">fun</span><span class="o">=</span><span class="n">log_score</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">gradient</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span>
        <span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">w_fuller</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
        <span class="n">ses</span> <span class="o">=</span> <span class="n">ics</span><span class="p">[</span><span class="n">ic_se</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;bb-pseudo-bma&quot;</span><span class="p">:</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ic_i_val</span> <span class="o">=</span> <span class="n">_ic_matrix</span><span class="p">(</span><span class="n">ics</span><span class="p">,</span> <span class="n">ic_i</span><span class="p">)</span>
        <span class="n">ic_i_val</span> <span class="o">=</span> <span class="n">ic_i_val</span> <span class="o">*</span> <span class="n">rows</span>

        <span class="n">b_weighting</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">dirichlet</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">*</span> <span class="n">rows</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">b_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">b_samples</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">z_bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b_samples</span><span class="p">):</span>
            <span class="n">z_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b_weighting</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ic_i_val</span><span class="p">)</span>
            <span class="n">u_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">z_b</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_b</span><span class="p">))</span> <span class="o">/</span> <span class="n">scale_value</span><span class="p">)</span>
            <span class="n">z_bs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_b</span>  <span class="c1"># pylint: disable=unsupported-assignment-operation</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u_weights</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ses</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">z_bs</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>

    <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;pseudo-bma&quot;</span><span class="p">:</span>
        <span class="n">min_ic</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ic</span><span class="p">]</span>
        <span class="n">z_rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">ics</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_ic</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale_value</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">z_rv</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z_rv</span><span class="p">)</span>
        <span class="n">ses</span> <span class="o">=</span> <span class="n">ics</span><span class="p">[</span><span class="n">ic_se</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="n">min_ic_i_val</span> <span class="o">=</span> <span class="n">ics</span><span class="p">[</span><span class="n">ic_i</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ics</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">scale_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">ic_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_ic_i_val</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_ic_i_val</span> <span class="o">-</span> <span class="n">res</span><span class="p">[</span><span class="n">ic_i</span><span class="p">])</span><span class="o">.</span><span class="n">values</span>
            <span class="n">d_ic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
            <span class="n">d_std_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
            <span class="n">std_err</span> <span class="o">=</span> <span class="n">ses</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">df_comp</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">res</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span>
                <span class="n">res</span><span class="p">[</span><span class="n">p_ic</span><span class="p">],</span>
                <span class="n">d_ic</span><span class="p">,</span>
                <span class="n">weight</span><span class="p">,</span>
                <span class="n">std_err</span><span class="p">,</span>
                <span class="n">d_std_err</span><span class="p">,</span>
                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;warning&quot;</span><span class="p">],</span>
                <span class="n">res</span><span class="p">[</span><span class="n">scale_col</span><span class="p">],</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_comp</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">ic</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_ic_matrix</span><span class="p">(</span><span class="n">ics</span><span class="p">,</span> <span class="n">ic_i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Store the previously computed pointwise predictive accuracy values (ics) in a 2D matrix.&quot;&quot;&quot;</span>
    <span class="n">cols</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ics</span><span class="p">[</span><span class="n">ic_i</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ic_i_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ics</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">val</span><span class="p">][</span><span class="n">ic_i</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of observations should be the same across all models&quot;</span><span class="p">)</span>

        <span class="n">ic_i_val</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ic</span>

    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ic_i_val</span>


<div class="viewcode-block" id="hpd"><a class="viewcode-back" href="../../../generated/arviz.hpd.html#arviz.hpd">[docs]</a><span class="k">def</span> <span class="nf">hpd</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">credible_interval</span><span class="o">=</span><span class="mf">0.94</span><span class="p">,</span> <span class="n">circular</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate highest posterior density (HPD) of array for given credible_interval.</span>

<span class="sd">    The HPD is the minimum width Bayesian credible interval (BCI). This implementation works only</span>
<span class="sd">    for unimodal distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : Numpy array</span>
<span class="sd">        An array containing posterior samples</span>
<span class="sd">    credible_interval : float, optional</span>
<span class="sd">        Credible interval to compute. Defaults to 0.94.</span>
<span class="sd">    circular : bool, optional</span>
<span class="sd">        Whether to compute the hpd taking into account `x` is a circular variable</span>
<span class="sd">        (in the range [-np.pi, np.pi]) or not. Defaults to False (i.e non-circular variables).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        lower and upper value of the interval.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate the hpd of a Normal random variable:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: import numpy as np</span>
<span class="sd">           ...: data = np.random.normal(size=2000)</span>
<span class="sd">           ...: az.hpd(data, credible_interval=.68)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">hpd_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">hpd</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">credible_interval</span><span class="o">=</span><span class="n">credible_interval</span><span class="p">,</span> <span class="n">circular</span><span class="o">=</span><span class="n">circular</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">ary</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">hpd_array</span>
    <span class="c1"># Make a copy of trace</span>
    <span class="n">ary</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">circular</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">circmean</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">ary</span> <span class="o">=</span> <span class="n">ary</span> <span class="o">-</span> <span class="n">mean</span>
        <span class="n">ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ary</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ary</span><span class="p">))</span>

    <span class="n">ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="n">interval_idx_inc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">credible_interval</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">n_intervals</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">interval_idx_inc</span>
    <span class="n">interval_width</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="n">interval_idx_inc</span><span class="p">:]</span> <span class="o">-</span> <span class="n">ary</span><span class="p">[:</span><span class="n">n_intervals</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval_width</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Too few elements for interval calculation. &quot;</span>
            <span class="s2">&quot;Check that credible_interval meets condition 0 =&lt; credible_interval &lt; 1&quot;</span>
        <span class="p">)</span>

    <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">interval_width</span><span class="p">)</span>
    <span class="n">hdi_min</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
    <span class="n">hdi_max</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="n">min_idx</span> <span class="o">+</span> <span class="n">interval_idx_inc</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">circular</span><span class="p">:</span>
        <span class="n">hdi_min</span> <span class="o">=</span> <span class="n">hdi_min</span> <span class="o">+</span> <span class="n">mean</span>
        <span class="n">hdi_max</span> <span class="o">=</span> <span class="n">hdi_max</span> <span class="o">+</span> <span class="n">mean</span>
        <span class="n">hdi_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">hdi_min</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">hdi_min</span><span class="p">))</span>
        <span class="n">hdi_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">hdi_max</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">hdi_max</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">hdi_min</span><span class="p">,</span> <span class="n">hdi_max</span><span class="p">])</span></div>


<div class="viewcode-block" id="loo"><a class="viewcode-back" href="../../../generated/arviz.loo.html#arviz.loo">[docs]</a><span class="k">def</span> <span class="nf">loo</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pointwise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s2">&quot;deviance&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pareto-smoothed importance sampling leave-one-out cross-validation.</span>

<span class="sd">    Calculates leave-one-out (LOO) cross-validation for out of sample predictive model fit,</span>
<span class="sd">    following Vehtari et al. (2017). Cross-validation is computed using Pareto-smoothed</span>
<span class="sd">    importance sampling (PSIS).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : obj</span>
<span class="sd">        Any object that can be converted to an az.InferenceData object. Refer to documentation</span>
<span class="sd">        of az.convert_to_inference_data for details</span>
<span class="sd">    pointwise : bool, optional</span>
<span class="sd">        if True the pointwise predictive accuracy will be returned. Defaults to False</span>
<span class="sd">    reff : float, optional</span>
<span class="sd">        Relative MCMC efficiency, `ess / n` i.e. number of effective samples divided by</span>
<span class="sd">        the number of actual samples. Computed from trace by default.</span>
<span class="sd">    scale : str</span>
<span class="sd">        Output scale for loo. Available options are:</span>

<span class="sd">        - `deviance` : (default) -2 * (log-score)</span>
<span class="sd">        - `log` : 1 * log-score (after Vehtari et al. (2017))</span>
<span class="sd">        - `negative_log` : -1 * (log-score)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.Series with the following rows:</span>
<span class="sd">    loo : approximated Leave-one-out cross-validation</span>
<span class="sd">    loo_se : standard error of loo</span>
<span class="sd">    p_loo : effective number of parameters</span>
<span class="sd">    shape_warn : bool</span>
<span class="sd">        True if the estimated shape parameter of</span>
<span class="sd">        Pareto distribution is greater than 0.7 for one or more samples</span>
<span class="sd">    loo_i : array of pointwise predictive accuracy, only if pointwise True</span>
<span class="sd">    pareto_k : array of Pareto shape values, only if pointwise True</span>
<span class="sd">    loo_scale : scale of the loo results</span>

<span class="sd">        The returned object has a custom print method that overrides pd.Series method. It is</span>
<span class="sd">        specific to expected log pointwise predictive density (elpd) information criteria.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate the LOO-CV of a model:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: az.loo(data)</span>

<span class="sd">    The custom print method can be seen here, printing only the relevant information and</span>
<span class="sd">    with a specific organization. ``IC_loo`` stands for information criteria, which is the</span>
<span class="sd">    `deviance` scale, the `log` (and `negative_log`) correspond to ``elpd`` (and ``-elpd``)</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [2]: az.loo(data, pointwise=True, scale=&quot;log&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inference_data</span> <span class="o">=</span> <span class="n">convert_to_inference_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;posterior&quot;</span><span class="p">,</span> <span class="s2">&quot;sample_stats&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inference_data</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Must be able to extract a </span><span class="si">{group}</span><span class="s2"> group from data!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;log_likelihood&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inference_data</span><span class="o">.</span><span class="n">sample_stats</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Data must include log_likelihood in sample_stats&quot;</span><span class="p">)</span>
    <span class="n">posterior</span> <span class="o">=</span> <span class="n">inference_data</span><span class="o">.</span><span class="n">posterior</span>
    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">inference_data</span><span class="o">.</span><span class="n">sample_stats</span><span class="o">.</span><span class="n">log_likelihood</span>
    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">))</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_data_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;deviance&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;negative_log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Valid scale values are &quot;deviance&quot;, &quot;log&quot;, &quot;negative_log&quot;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">reff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_chains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">posterior</span><span class="o">.</span><span class="n">chain</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_chains</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">reff</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ess_p</span> <span class="o">=</span> <span class="n">ess</span><span class="p">(</span><span class="n">posterior</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span>
            <span class="c1"># this mean is over all data variables</span>
            <span class="n">reff</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ess_p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ess_p</span><span class="o">.</span><span class="n">data_vars</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_samples</span>
            <span class="p">)</span>

    <span class="n">log_weights</span><span class="p">,</span> <span class="n">pareto_shape</span> <span class="o">=</span> <span class="n">psislw</span><span class="p">(</span><span class="o">-</span><span class="n">log_likelihood</span><span class="p">,</span> <span class="n">reff</span><span class="p">)</span>
    <span class="n">log_weights</span> <span class="o">+=</span> <span class="n">log_likelihood</span>

    <span class="n">warn_mg</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pareto_shape</span> <span class="o">&gt;</span> <span class="mf">0.7</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Estimated shape parameter of Pareto distribution is greater than 0.7 for &quot;</span>
            <span class="s2">&quot;one or more samples. You should consider using a more robust model, this is because &quot;</span>
            <span class="s2">&quot;importance sampling is less likely to work well if the marginal posterior and &quot;</span>
            <span class="s2">&quot;LOO posterior are very different. This is more likely to happen with a non-robust &quot;</span>
            <span class="s2">&quot;model and highly influential observations.&quot;</span>
        <span class="p">)</span>
        <span class="n">warn_mg</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">ufunc_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;n_dims&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;ravel&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_core_dims&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;samples&quot;</span><span class="p">]]}</span>
    <span class="n">loo_lppd_i</span> <span class="o">=</span> <span class="n">scale_value</span> <span class="o">*</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
        <span class="n">_logsumexp</span><span class="p">,</span> <span class="n">log_weights</span><span class="p">,</span> <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="n">loo_lppd</span> <span class="o">=</span> <span class="n">loo_lppd_i</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">loo_lppd_se</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_data_points</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">loo_lppd_i</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="n">lppd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
            <span class="n">_logsumexp</span><span class="p">,</span>
            <span class="n">log_likelihood</span><span class="p">,</span>
            <span class="n">func_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;b_inv&quot;</span><span class="p">:</span> <span class="n">n_samples</span><span class="p">},</span>
            <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="p">)</span>
    <span class="n">p_loo</span> <span class="o">=</span> <span class="n">lppd</span> <span class="o">-</span> <span class="n">loo_lppd</span> <span class="o">/</span> <span class="n">scale_value</span>

    <span class="k">if</span> <span class="n">pointwise</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">loo_lppd</span><span class="p">,</span> <span class="n">loo_lppd_i</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The point-wise LOO is the same with the sum LOO, please double check &quot;</span>
                <span class="s2">&quot;the Observed RV in your model to make sure it returns element-wise logp.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ELPDData</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span>
                <span class="n">loo_lppd</span><span class="p">,</span>
                <span class="n">loo_lppd_se</span><span class="p">,</span>
                <span class="n">p_loo</span><span class="p">,</span>
                <span class="n">n_samples</span><span class="p">,</span>
                <span class="n">n_data_points</span><span class="p">,</span>
                <span class="n">warn_mg</span><span class="p">,</span>
                <span class="n">loo_lppd_i</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;loo_i&quot;</span><span class="p">),</span>
                <span class="n">pareto_shape</span><span class="p">,</span>
                <span class="n">scale</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;loo&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loo_se&quot;</span><span class="p">,</span>
                <span class="s2">&quot;p_loo&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_samples&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_data_points&quot;</span><span class="p">,</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loo_i&quot;</span><span class="p">,</span>
                <span class="s2">&quot;pareto_k&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loo_scale&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ELPDData</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">loo_lppd</span><span class="p">,</span> <span class="n">loo_lppd_se</span><span class="p">,</span> <span class="n">p_loo</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_data_points</span><span class="p">,</span> <span class="n">warn_mg</span><span class="p">,</span> <span class="n">scale</span><span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;loo&quot;</span><span class="p">,</span> <span class="s2">&quot;loo_se&quot;</span><span class="p">,</span> <span class="s2">&quot;p_loo&quot;</span><span class="p">,</span> <span class="s2">&quot;n_samples&quot;</span><span class="p">,</span> <span class="s2">&quot;n_data_points&quot;</span><span class="p">,</span> <span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="s2">&quot;loo_scale&quot;</span><span class="p">],</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="psislw"><a class="viewcode-back" href="../../../generated/arviz.psislw.html#arviz.psislw">[docs]</a><span class="k">def</span> <span class="nf">psislw</span><span class="p">(</span><span class="n">log_weights</span><span class="p">,</span> <span class="n">reff</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pareto smoothed importance sampling (PSIS).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_weights : array</span>
<span class="sd">        Array of size (n_observations, n_samples)</span>
<span class="sd">    reff : float</span>
<span class="sd">        relative MCMC efficiency, `ess / n`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lw_out : array</span>
<span class="sd">        Smoothed log weights</span>
<span class="sd">    kss : array</span>
<span class="sd">        Pareto tail indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">log_weights</span><span class="p">,</span> <span class="s2">&quot;samples&quot;</span><span class="p">):</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_weights</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">size</span> <span class="k">for</span> <span class="n">size</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">log_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">log_weights</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="s2">&quot;samples&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">log_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">log_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># precalculate constants</span>
    <span class="n">cutoff_ind</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">/</span> <span class="n">reff</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">cutoffmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member, assignment-from-no-return</span>
    <span class="n">k_min</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="c1"># create output array with proper dimensions</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">log_weights</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">)])</span>

    <span class="c1"># define kwargs</span>
    <span class="n">func_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cutoff_ind&quot;</span><span class="p">:</span> <span class="n">cutoff_ind</span><span class="p">,</span> <span class="s2">&quot;cutoffmin&quot;</span><span class="p">:</span> <span class="n">cutoffmin</span><span class="p">,</span> <span class="s2">&quot;k_min&quot;</span><span class="p">:</span> <span class="n">k_min</span><span class="p">,</span> <span class="s2">&quot;out&quot;</span><span class="p">:</span> <span class="n">out</span><span class="p">}</span>
    <span class="n">ufunc_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;n_dims&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;n_output&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;ravel&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;check_shape&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_core_dims&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;samples&quot;</span><span class="p">]],</span> <span class="s2">&quot;output_core_dims&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;sample&quot;</span><span class="p">],</span> <span class="p">[]]}</span>
    <span class="n">log_weights</span><span class="p">,</span> <span class="n">pareto_shape</span> <span class="o">=</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
        <span class="n">_psislw</span><span class="p">,</span> <span class="n">log_weights</span><span class="p">,</span> <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span> <span class="n">func_kwargs</span><span class="o">=</span><span class="n">func_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log_weights</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="n">log_weights</span> <span class="o">=</span> <span class="n">log_weights</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;log_weights&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">sample</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pareto_shape</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="n">pareto_shape</span> <span class="o">=</span> <span class="n">pareto_shape</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;pareto_shape&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">log_weights</span><span class="p">,</span> <span class="n">pareto_shape</span></div>


<span class="k">def</span> <span class="nf">_psislw</span><span class="p">(</span><span class="n">log_weights</span><span class="p">,</span> <span class="n">cutoff_ind</span><span class="p">,</span> <span class="n">cutoffmin</span><span class="p">,</span> <span class="n">k_min</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pareto smoothed importance sampling (PSIS) for a 1D vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_weights : array</span>
<span class="sd">        Array of length n_observations</span>
<span class="sd">    cutoff_ind : int</span>
<span class="sd">    cutoffmin : float</span>
<span class="sd">    k_min : float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lw_out : array</span>
<span class="sd">        Smoothed log weights</span>
<span class="sd">    kss : float</span>
<span class="sd">        Pareto tail index</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">log_weights</span><span class="p">)</span>

    <span class="c1"># improve numerical accuracy</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># sort the array</span>
    <span class="n">x_sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># divide log weights into body and right tail</span>
    <span class="n">xcutoff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">x_sort_ind</span><span class="p">[</span><span class="n">cutoff_ind</span><span class="p">]],</span> <span class="n">cutoffmin</span><span class="p">)</span>

    <span class="n">expxcutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">xcutoff</span><span class="p">)</span>
    <span class="n">tailinds</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">xcutoff</span><span class="p">)</span>  <span class="c1"># pylint: disable=unbalanced-tuple-unpacking</span>
    <span class="n">x_tail</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">tailinds</span><span class="p">]</span>
    <span class="n">tail_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_tail</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tail_len</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># not enough tail samples for gpdfit</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># order of tail samples</span>
        <span class="n">x_tail_si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x_tail</span><span class="p">)</span>
        <span class="c1"># fit generalized Pareto distribution to the right tail samples</span>
        <span class="n">x_tail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_tail</span><span class="p">)</span> <span class="o">-</span> <span class="n">expxcutoff</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">_gpdfit</span><span class="p">(</span><span class="n">x_tail</span><span class="p">[</span><span class="n">x_tail_si</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">k_min</span><span class="p">:</span>
            <span class="c1"># no smoothing if short tail or GPD fit failed</span>
            <span class="c1"># compute ordered statistic for the fit</span>
            <span class="n">sti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">)</span> <span class="o">/</span> <span class="n">tail_len</span>
            <span class="n">smoothed_tail</span> <span class="o">=</span> <span class="n">_gpinv</span><span class="p">(</span><span class="n">sti</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="n">smoothed_tail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>  <span class="c1"># pylint: disable=assignment-from-no-return</span>
                <span class="n">smoothed_tail</span> <span class="o">+</span> <span class="n">expxcutoff</span>
            <span class="p">)</span>
            <span class="c1"># place the smoothed tail into the output array</span>
            <span class="n">x</span><span class="p">[</span><span class="n">tailinds</span><span class="p">[</span><span class="n">x_tail_si</span><span class="p">]]</span> <span class="o">=</span> <span class="n">smoothed_tail</span>
            <span class="c1"># truncate smoothed values to the largest raw weight 0</span>
            <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># renormalize weights</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">_logsumexp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">_gpdfit</span><span class="p">(</span><span class="n">ary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the parameters for the Generalized Pareto Distribution (GPD).</span>

<span class="sd">    Empirical Bayes estimate for the parameters of the generalized Pareto</span>
<span class="sd">    distribution given the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary : array</span>
<span class="sd">        sorted 1D data array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    k : float</span>
<span class="sd">        estimated shape parameter</span>
<span class="sd">    sigma : float</span>
<span class="sd">        estimated scale parameter</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prior_bs</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">prior_k</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="n">m_est</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="n">b_ary</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m_est</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m_est</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="n">b_ary</span> <span class="o">/=</span> <span class="n">prior_bs</span> <span class="o">*</span> <span class="n">ary</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">b_ary</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ary</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">k_ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">b_ary</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ary</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>
    <span class="n">len_scale</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b_ary</span> <span class="o">/</span> <span class="n">k_ary</span><span class="p">))</span> <span class="o">-</span> <span class="n">k_ary</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">len_scale</span> <span class="o">-</span> <span class="n">len_scale</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># remove negligible weights</span>
    <span class="n">real_idxs</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">real_idxs</span><span class="p">):</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">real_idxs</span><span class="p">]</span>
        <span class="n">b_ary</span> <span class="o">=</span> <span class="n">b_ary</span><span class="p">[</span><span class="n">real_idxs</span><span class="p">]</span>
    <span class="c1"># normalise weights</span>
    <span class="n">weights</span> <span class="o">/=</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># posterior mean for b</span>
    <span class="n">b_post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b_ary</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span>
    <span class="c1"># estimate for k</span>
    <span class="n">k_post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">b_post</span> <span class="o">*</span> <span class="n">ary</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># pylint: disable=invalid-unary-operand-type,no-member</span>
    <span class="c1"># add prior for k_post</span>
    <span class="n">k_post</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">k_post</span> <span class="o">+</span> <span class="n">prior_k</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">prior_k</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="o">-</span><span class="n">k_post</span> <span class="o">/</span> <span class="n">b_post</span>

    <span class="k">return</span> <span class="n">k_post</span><span class="p">,</span> <span class="n">sigma</span>


<span class="k">def</span> <span class="nf">_gpinv</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Inverse Generalized Pareto distribution function.&quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=unsupported-assignment-operation, invalid-unary-operand-type</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">probs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">probs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ok</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">probs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="o">-</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">probs</span><span class="p">))</span> <span class="o">/</span> <span class="n">kappa</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">sigma</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">probs</span><span class="p">[</span><span class="n">ok</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="o">-</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">probs</span><span class="p">[</span><span class="n">ok</span><span class="p">]))</span> <span class="o">/</span> <span class="n">kappa</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">sigma</span>
        <span class="n">x</span><span class="p">[</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">kappa</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sigma</span> <span class="o">/</span> <span class="n">kappa</span>
    <span class="k">return</span> <span class="n">x</span>


<div class="viewcode-block" id="r2_score"><a class="viewcode-back" href="../../../generated/arviz.r2_score.html#arviz.r2_score">[docs]</a><span class="k">def</span> <span class="nf">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;R for Bayesian regression models. Only valid for linear models.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y_true : array-like of shape = (n_samples) or (n_samples, n_outputs)</span>
<span class="sd">        Ground truth (correct) target values.</span>
<span class="sd">    y_pred : array-like of shape = (n_samples) or (n_samples, n_outputs)</span>
<span class="sd">        Estimated target values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pandas Series with the following indices:</span>
<span class="sd">    r2: Bayesian R</span>
<span class="sd">    r2_std: standard deviation of the Bayesian R.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_numba_flag</span> <span class="o">=</span> <span class="n">Numba</span><span class="o">.</span><span class="n">numba_flag</span>
    <span class="k">if</span> <span class="n">y_pred</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">var_y_est</span> <span class="o">=</span> <span class="n">_numba_var</span><span class="p">(</span><span class="n">svar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
        <span class="n">var_e</span> <span class="o">=</span> <span class="n">_numba_var</span><span class="p">(</span><span class="n">svar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">var_y_est</span> <span class="o">=</span> <span class="n">_numba_var</span><span class="p">(</span><span class="n">svar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">y_pred</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">var_e</span> <span class="o">=</span> <span class="n">_numba_var</span><span class="p">(</span><span class="n">svar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">r_squared</span> <span class="o">=</span> <span class="n">var_y_est</span> <span class="o">/</span> <span class="p">(</span><span class="n">var_y_est</span> <span class="o">+</span> <span class="n">var_e</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r_squared</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">r_squared</span><span class="p">)],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;r2&quot;</span><span class="p">,</span> <span class="s2">&quot;r2_std&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="summary"><a class="viewcode-back" href="../../../generated/arviz.summary.html#arviz.summary">[docs]</a><span class="k">def</span> <span class="nf">summary</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">var_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;wide&quot;</span><span class="p">,</span>
    <span class="n">round_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">include_circ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">stat_funcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">credible_interval</span><span class="o">=</span><span class="mf">0.94</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
    <span class="n">index_origin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a data frame with summary statistics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : obj</span>
<span class="sd">        Any object that can be converted to an az.InferenceData object</span>
<span class="sd">        Refer to documentation of az.convert_to_dataset for details</span>
<span class="sd">    var_names : list</span>
<span class="sd">        Names of variables to include in summary</span>
<span class="sd">    include_circ : bool</span>
<span class="sd">        Whether to include circular statistics</span>
<span class="sd">    fmt : {&#39;wide&#39;, &#39;long&#39;, &#39;xarray&#39;}</span>
<span class="sd">        Return format is either pandas.DataFrame {&#39;wide&#39;, &#39;long&#39;} or xarray.Dataset {&#39;xarray&#39;}.</span>
<span class="sd">    round_to : int</span>
<span class="sd">        Number of decimals used to round results. Defaults to 2. Use &quot;none&quot; to return raw numbers.</span>
<span class="sd">    stat_funcs : dict</span>
<span class="sd">        A list of functions or a dict of functions with function names as keys used to calculate</span>
<span class="sd">        statistics. By default, the mean, standard deviation, simulation standard error, and</span>
<span class="sd">        highest posterior density intervals are included.</span>

<span class="sd">        The functions will be given one argument, the samples for a variable as an nD array,</span>
<span class="sd">        The functions should be in the style of a ufunc and return a single number. For example,</span>
<span class="sd">        `np.mean`, or `scipy.stats.var` would both work.</span>
<span class="sd">    extend : boolean</span>
<span class="sd">        If True, use the statistics returned by `stat_funcs` in addition to, rather than in place</span>
<span class="sd">        of, the default statistics. This is only meaningful when `stat_funcs` is not None.</span>
<span class="sd">    credible_interval : float, optional</span>
<span class="sd">        Credible interval to plot. Defaults to 0.94. This is only meaningful when `stat_funcs` is</span>
<span class="sd">        None.</span>
<span class="sd">    order : {&quot;C&quot;, &quot;F&quot;}</span>
<span class="sd">        If fmt is &quot;wide&quot;, use either C or F unpacking order. Defaults to C.</span>
<span class="sd">    index_origin : int</span>
<span class="sd">        If fmt is &quot;wide, select n-based indexing for multivariate parameters. Defaults to 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        With summary statistics for each variable. Defaults statistics are: `mean`, `sd`,</span>
<span class="sd">        `hpd_3%`, `hpd_97%`, `mcse_mean`, `mcse_sd`, `ess_bulk`, `ess_tail` and `r_hat`.</span>
<span class="sd">        `r_hat` is only computed for traces with 2 or more chains.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: az.summary(data, var_names=[&quot;mu&quot;, &quot;tau&quot;])</span>

<span class="sd">    Other statistics can be calculated by passing a list of functions</span>
<span class="sd">    or a dictionary with key, function pairs.</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import numpy as np</span>
<span class="sd">           ...: def median_sd(x):</span>
<span class="sd">           ...:     median = np.percentile(x, 50)</span>
<span class="sd">           ...:     sd = np.sqrt(np.mean((x-median)**2))</span>
<span class="sd">           ...:     return sd</span>
<span class="sd">           ...:</span>
<span class="sd">           ...: func_dict = {</span>
<span class="sd">           ...:     &quot;std&quot;: np.std,</span>
<span class="sd">           ...:     &quot;median_std&quot;: median_sd,</span>
<span class="sd">           ...:     &quot;5%&quot;: lambda x: np.percentile(x, 5),</span>
<span class="sd">           ...:     &quot;median&quot;: lambda x: np.percentile(x, 50),</span>
<span class="sd">           ...:     &quot;95%&quot;: lambda x: np.percentile(x, 95),</span>
<span class="sd">           ...: }</span>
<span class="sd">           ...: az.summary(</span>
<span class="sd">           ...:     data,</span>
<span class="sd">           ...:     var_names=[&quot;mu&quot;, &quot;tau&quot;],</span>
<span class="sd">           ...:     stat_funcs=func_dict,</span>
<span class="sd">           ...:     extend=False</span>
<span class="sd">           ...: )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">posterior</span> <span class="o">=</span> <span class="n">convert_to_dataset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;posterior&quot;</span><span class="p">)</span>
    <span class="n">var_names</span> <span class="o">=</span> <span class="n">_var_names</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="n">posterior</span><span class="p">)</span>
    <span class="n">posterior</span> <span class="o">=</span> <span class="n">posterior</span> <span class="k">if</span> <span class="n">var_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">posterior</span><span class="p">[</span><span class="n">var_names</span><span class="p">]</span>

    <span class="n">fmt_group</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;wide&quot;</span><span class="p">,</span> <span class="s2">&quot;long&quot;</span><span class="p">,</span> <span class="s2">&quot;xarray&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fmt_group</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid format: &#39;</span><span class="si">{}</span><span class="s2">&#39;! Formatting options are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">fmt_group</span><span class="p">))</span>

    <span class="n">unpack_order_group</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">order</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unpack_order_group</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid order: &#39;</span><span class="si">{}</span><span class="s2">&#39;! Unpacking options are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">unpack_order_group</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">credible_interval</span>

    <span class="n">extra_metrics</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">extra_metric_names</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">stat_funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stat_funcs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">stat_func_name</span><span class="p">,</span> <span class="n">stat_func</span> <span class="ow">in</span> <span class="n">stat_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">extra_metrics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                        <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">stat_func</span><span class="p">),</span> <span class="n">posterior</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">extra_metric_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat_func_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">stat_func</span> <span class="ow">in</span> <span class="n">stat_funcs</span><span class="p">:</span>
                <span class="n">extra_metrics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                        <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">stat_func</span><span class="p">),</span> <span class="n">posterior</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">extra_metric_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat_func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">extend</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">))</span>

        <span class="n">sd</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">hpd_lower</span><span class="p">,</span> <span class="n">hpd_higher</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">hpd</span><span class="p">,</span> <span class="n">n_output</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
            <span class="n">posterior</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">credible_interval</span><span class="o">=</span><span class="n">credible_interval</span><span class="p">),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">([]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">include_circ</span><span class="p">:</span>
        <span class="n">circ_mean</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">circmean</span><span class="p">),</span>
            <span class="n">posterior</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
        <span class="p">)</span>
        <span class="n">_numba_flag</span> <span class="o">=</span> <span class="n">Numba</span><span class="o">.</span><span class="n">numba_flag</span>
        <span class="n">func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">_numba_flag</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">_circular_standard_deviation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">circstd</span>
        <span class="n">circ_sd</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
            <span class="n">posterior</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
        <span class="p">)</span>

        <span class="n">circ_mcse</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">_mc_error</span><span class="p">),</span>
            <span class="n">posterior</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">circular</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
        <span class="p">)</span>

        <span class="n">circ_hpd_lower</span><span class="p">,</span> <span class="n">circ_hpd_higher</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">hpd</span><span class="p">,</span> <span class="n">n_output</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
            <span class="n">posterior</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">credible_interval</span><span class="o">=</span><span class="n">credible_interval</span><span class="p">,</span> <span class="n">circular</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">([]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
        <span class="p">)</span>

    <span class="n">mcse_mean</span><span class="p">,</span> <span class="n">mcse_sd</span><span class="p">,</span> <span class="n">ess_mean</span><span class="p">,</span> <span class="n">ess_sd</span><span class="p">,</span> <span class="n">ess_bulk</span><span class="p">,</span> <span class="n">ess_tail</span><span class="p">,</span> <span class="n">r_hat</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
        <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">_multichain_statistics</span><span class="p">,</span> <span class="n">n_output</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">ravel</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">posterior</span><span class="p">,</span>
        <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
        <span class="n">output_core_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">([]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)),</span>
    <span class="p">)</span>

    <span class="c1"># Combine metrics</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">metric_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">extend</span><span class="p">:</span>
        <span class="n">metrics</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">mean</span><span class="p">,</span>
                <span class="n">sd</span><span class="p">,</span>
                <span class="n">hpd_lower</span><span class="p">,</span>
                <span class="n">hpd_higher</span><span class="p">,</span>
                <span class="n">mcse_mean</span><span class="p">,</span>
                <span class="n">mcse_sd</span><span class="p">,</span>
                <span class="n">ess_mean</span><span class="p">,</span>
                <span class="n">ess_sd</span><span class="p">,</span>
                <span class="n">ess_bulk</span><span class="p">,</span>
                <span class="n">ess_tail</span><span class="p">,</span>
                <span class="n">r_hat</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">metric_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                <span class="s2">&quot;sd&quot;</span><span class="p">,</span>
                <span class="s2">&quot;hpd_</span><span class="si">{:g}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                <span class="s2">&quot;hpd_</span><span class="si">{:g}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                <span class="s2">&quot;mcse_mean&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mcse_sd&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ess_mean&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ess_sd&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ess_bulk&quot;</span><span class="p">,</span>
                <span class="s2">&quot;ess_tail&quot;</span><span class="p">,</span>
                <span class="s2">&quot;r_hat&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">include_circ</span><span class="p">:</span>
        <span class="n">metrics</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">circ_mean</span><span class="p">,</span> <span class="n">circ_sd</span><span class="p">,</span> <span class="n">circ_hpd_lower</span><span class="p">,</span> <span class="n">circ_hpd_higher</span><span class="p">,</span> <span class="n">circ_mcse</span><span class="p">))</span>
        <span class="n">metric_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;circular_mean&quot;</span><span class="p">,</span>
                <span class="s2">&quot;circular_sd&quot;</span><span class="p">,</span>
                <span class="s2">&quot;circular_hpd_</span><span class="si">{:g}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                <span class="s2">&quot;circular_hpd_</span><span class="si">{:g}</span><span class="s2">%&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)),</span>
                <span class="s2">&quot;circular_mcse&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="n">metrics</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra_metrics</span><span class="p">)</span>
    <span class="n">metric_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra_metric_names</span><span class="p">)</span>
    <span class="n">joined</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;metric&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric_names</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;wide&quot;</span><span class="p">:</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">joined</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="n">data_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span> <span class="k">else</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">ser</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">[(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="o">*</span><span class="n">idx</span><span class="p">)]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
                    <span class="n">key_index</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">index_origin</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">)))</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">key_index</span><span class="p">)</span>
                    <span class="n">data_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ser</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span>
                <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">T</span>
            <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;long&quot;</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">joined</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;metric&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">joined</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">round_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">round_to</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">)):</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">summary_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">round_to</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">round_to</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;long&quot;</span><span class="p">,</span> <span class="s2">&quot;wide&quot;</span><span class="p">)):</span>
        <span class="c1"># Don&#39;t round xarray object by default (even with &quot;none&quot;)</span>
        <span class="n">decimals</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">col</span><span class="p">:</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;ess_mean&quot;</span><span class="p">,</span> <span class="s2">&quot;ess_sd&quot;</span><span class="p">,</span> <span class="s2">&quot;ess_bulk&quot;</span><span class="p">,</span> <span class="s2">&quot;ess_tail&quot;</span><span class="p">,</span> <span class="s2">&quot;r_hat&quot;</span><span class="p">}</span>
            <span class="k">else</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="s2">&quot;r_hat&quot;</span>
            <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">summary_df</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">}</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">summary_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">summary_df</span></div>


<div class="viewcode-block" id="waic"><a class="viewcode-back" href="../../../generated/arviz.waic.html#arviz.waic">[docs]</a><span class="k">def</span> <span class="nf">waic</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pointwise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s2">&quot;deviance&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the widely available information criterion.</span>

<span class="sd">    Also calculates the WAIC&#39;s standard error and the effective number of</span>
<span class="sd">    parameters of the samples in trace from model. Read more theory here - in</span>
<span class="sd">    a paper by some of the leading authorities on model selection</span>
<span class="sd">    &lt;dx.doi.org/10.1111/1467-9868.00353&gt;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : obj</span>
<span class="sd">        Any object that can be converted to an az.InferenceData object</span>
<span class="sd">        Refer to documentation of az.convert_to_inference_data for details</span>
<span class="sd">    pointwise : bool</span>
<span class="sd">        if True the pointwise predictive accuracy will be returned.</span>
<span class="sd">        Default False</span>
<span class="sd">    scale : str</span>
<span class="sd">        Output scale for loo. Available options are:</span>

<span class="sd">        - `deviance` : (default) -2 * (log-score)</span>
<span class="sd">        - `log` : 1 * log-score</span>
<span class="sd">        - `negative_log` : -1 * (log-score)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Series with the following rows:</span>
<span class="sd">    waic : widely available information criterion</span>
<span class="sd">    waic_se : standard error of waic</span>
<span class="sd">    p_waic : effective number parameters</span>
<span class="sd">    var_warn : bool</span>
<span class="sd">        True if posterior variance of the log predictive</span>
<span class="sd">        densities exceeds 0.4</span>
<span class="sd">    waic_i : and array of the pointwise predictive accuracy, only if pointwise True</span>
<span class="sd">    waic_scale : scale of the waic results</span>

<span class="sd">        The returned object has a custom print method that overrides pd.Series method. It is</span>
<span class="sd">        specific to expected log pointwise predictive density (elpd) information criteria.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate the WAIC of a model:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: az.waic(data, pointwise=True)</span>

<span class="sd">    The custom print method can be seen here, printing only the relevant information and</span>
<span class="sd">    with a specific organization. ``IC_loo`` stands for information criteria, which is the</span>
<span class="sd">    `deviance` scale, the `log` (and `negative_log`) correspond to ``elpd`` (and ``-elpd``)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inference_data</span> <span class="o">=</span> <span class="n">convert_to_inference_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;sample_stats&quot;</span><span class="p">,):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inference_data</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Must be able to extract a </span><span class="si">{group}</span><span class="s2"> group from data!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;log_likelihood&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inference_data</span><span class="o">.</span><span class="n">sample_stats</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Data must include log_likelihood in sample_stats&quot;</span><span class="p">)</span>
    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">inference_data</span><span class="o">.</span><span class="n">sample_stats</span><span class="o">.</span><span class="n">log_likelihood</span>

    <span class="k">if</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;deviance&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;negative_log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Valid scale values are &quot;deviance&quot;, &quot;log&quot;, &quot;negative_log&quot;&#39;</span><span class="p">)</span>

    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">))</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_data_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">ufunc_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;n_dims&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;ravel&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_core_dims&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;samples&quot;</span><span class="p">]]}</span>
    <span class="n">lppd_i</span> <span class="o">=</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
        <span class="n">_logsumexp</span><span class="p">,</span>
        <span class="n">log_likelihood</span><span class="p">,</span>
        <span class="n">func_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;b_inv&quot;</span><span class="p">:</span> <span class="n">n_samples</span><span class="p">},</span>
        <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="n">vars_lpd</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="p">)</span>
    <span class="n">warn_mg</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">vars_lpd</span> <span class="o">&gt;</span> <span class="mf">0.4</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;For one or more samples the posterior variance of the log predictive</span>
<span class="sd">        densities exceeds 0.4. This could be indication of WAIC starting to fail see</span>
<span class="sd">        http://arxiv.org/abs/1507.04544 for details</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">)</span>
        <span class="n">warn_mg</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">waic_i</span> <span class="o">=</span> <span class="n">scale_value</span> <span class="o">*</span> <span class="p">(</span><span class="n">lppd_i</span> <span class="o">-</span> <span class="n">vars_lpd</span><span class="p">)</span>
    <span class="n">waic_se</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_data_points</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">waic_i</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="n">waic_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">waic_i</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">p_waic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vars_lpd</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pointwise</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">waic_sum</span><span class="p">,</span> <span class="n">waic_i</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;The point-wise WAIC is the same with the sum WAIC, please double check</span>
<span class="sd">            the Observed RV in your model to make sure it returns element-wise logp.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ELPDData</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span>
                <span class="n">waic_sum</span><span class="p">,</span>
                <span class="n">waic_se</span><span class="p">,</span>
                <span class="n">p_waic</span><span class="p">,</span>
                <span class="n">n_samples</span><span class="p">,</span>
                <span class="n">n_data_points</span><span class="p">,</span>
                <span class="n">warn_mg</span><span class="p">,</span>
                <span class="n">waic_i</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;waic_i&quot;</span><span class="p">),</span>
                <span class="n">scale</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_se&quot;</span><span class="p">,</span>
                <span class="s2">&quot;p_waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_samples&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_data_points&quot;</span><span class="p">,</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_i&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_scale&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ELPDData</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">waic_sum</span><span class="p">,</span> <span class="n">waic_se</span><span class="p">,</span> <span class="n">p_waic</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_data_points</span><span class="p">,</span> <span class="n">warn_mg</span><span class="p">,</span> <span class="n">scale</span><span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_se&quot;</span><span class="p">,</span>
                <span class="s2">&quot;p_waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_samples&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_data_points&quot;</span><span class="p">,</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_scale&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018, ArviZ devs.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>